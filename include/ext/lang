/**
 * @file lang
 * @author Jung-kang Lee (ntoskrnl7@gmail.com)
 * @brief This module implements language helper features.
 *
 * @copyright Copyright (c) 2020 C++ Extended template library Authors
 *
 */

#pragma once

#ifndef _EXT_LANG_
#define _EXT_LANG_

#include "string"

namespace ext {
namespace lang {
namespace ko_kr {
namespace numeric {
inline std::wstring nominal(uint64_t number, const wchar_t *zero = L"영") {
  if (number < 10) {
    const wchar_t *str[] = {zero,  L"일", L"이", L"삼", L"사",
                            L"오", L"육", L"칠", L"팔", L"구"};
    return str[number];
  }
  if (number < 100) {
    uint64_t quotient = number / 10;
    uint64_t remainder = number % 10;
    return ((quotient == 1) ? L"십" : nominal(quotient, L"") + L"십") +
           nominal(remainder, L"");
  }
  if (number < 1000) {
    uint64_t quotient = number / 100;
    uint64_t remainder = number % 100;
    return ((quotient == 1) ? L"백" : nominal(quotient, L"") + L"백") +
           nominal(remainder, L"");
  }
  if (number < 10000) {
    uint64_t quotient = number / 1000;
    uint64_t remainder = number % 1000;
    return ((quotient == 1) ? L"천" : nominal(quotient, L"") + L"천") +
           nominal(remainder, L"");
  }
  if (number < 100000000) {
    uint64_t quotient = number / 10000;
    uint64_t remainder = number % 10000;
    return ((quotient == 1) ? L"만" : nominal(quotient, L"") + L"만") +
           nominal(remainder, L"");
  }
  if (number < 1000000000000) {
    uint64_t quotient = number / 100000000;
    uint64_t remainder = number % 100000000;
    return ((quotient == 1) ? L"억" : nominal(quotient, L"") + L"억") +
           nominal(remainder, L"");
  }
  if (number < 10000000000000000) {
    uint64_t quotient = number / 1000000000000;
    uint64_t remainder = number % 1000000000000;
    return ((quotient == 1) ? L"조" : nominal(quotient, L"") + L"조") +
           nominal(remainder, L"");
  }
  uint64_t quotient = number / 10000000000000000;
  uint64_t remainder = number % 10000000000000000;
  return ((quotient == 1) ? L"경" : nominal(quotient, L"") + L"경") +
         nominal(remainder, L"");
}

inline std::wstring ordinal(uint64_t number, const wchar_t *unit = L"째",
                            const wchar_t *first = L"첫") {
  if (number == 0) {
    if (unit[0] == L'째') {
      return unit;
    }
    return std::wstring(L" ") + unit;
  }
  if (number < 10) {
    if (unit[0] == L'째') {
      const std::wstring str[] = {L"",     first,   L"둘",   L"셋",   L"넷",
                                  L"다섯", L"여섯", L"일곱", L"여덟", L"아홉"};
      return str[number] + unit;
    }
    const std::wstring str[] = {L"",     first,   L"두",   L"세",   L"네",
                                L"다섯", L"여섯", L"일곱", L"여덟", L"아홉"};
    return str[number] + L" " + unit;
  }
  if (number < 20) {
    return L"열" + ordinal(number - 10, unit, L"한");
  }
  if (number == 20) {
    return std::wstring(L"스무") + unit;
  }
  if (number < 30) {
    return L"스물" + ordinal(number - 20, unit, L"한");
  }
  if (number < 40) {
    return L"서른" + ordinal(number - 30, unit, L"한");
  }
  if (number < 50) {
    return L"마흔" + ordinal(number - 40, unit, L"한");
  }
  if (number < 60) {
    return L"쉰" + ordinal(number - 50, unit, L"한");
  }
  if (number < 70) {
    return L"예순" + ordinal(number - 60, unit, L"한");
  }
  if (number < 80) {
    return L"일흔" + ordinal(number - 70, unit, L"한");
  }
  if (number < 90) {
    return L"여든" + ordinal(number - 80, unit, L"한");
  }
  if (number < 100) {
    return L"아흔" + ordinal(number - 90, unit, L"한");
  }
  if (number < 1000) {
    uint64_t quotient = number / 100;
    uint64_t remainder = number % 100;
    return ((quotient == 1) ? L"백" : nominal(quotient, L"") + L"백") +
           ordinal(remainder, unit, L"한");
  }
  if (number < 10000) {
    uint64_t quotient = number / 1000;
    uint64_t remainder = number % 1000;
    return ((quotient == 1) ? L"천" : nominal(quotient, L"") + L"천") +
           ordinal(remainder, unit, L"한");
  }
  if (number < 100000000) {
    uint64_t quotient = number / 10000;
    uint64_t remainder = number % 10000;
    return ((quotient == 1) ? L"만" : nominal(quotient, L"") + L"만") +
           ordinal(remainder, unit, L"한");
  }
  if (number < 1000000000000) {
    uint64_t quotient = number / 100000000;
    uint64_t remainder = number % 100000000;
    return ((quotient == 1) ? L"억" : nominal(quotient, L"") + L"억") +
           ordinal(remainder, unit, L"한");
  }
  if (number < 10000000000000000) {
    uint64_t quotient = number / 1000000000000;
    uint64_t remainder = number % 1000000000000;
    return ((quotient == 1) ? L"조" : nominal(quotient, L"") + L"조") +
           ordinal(remainder, unit, L"한");
  }
  uint64_t quotient = number / 10000000000000000;
  uint64_t remainder = number % 10000000000000000;
  return ((quotient == 1) ? L"경" : nominal(quotient, L"") + L"경") +
         ordinal(remainder, unit, L"한");
}

inline std::wstring cardinal(uint64_t number, const wchar_t *unit = NULL,
                             const wchar_t *first = L"하나") {
  if (number < 10) {
    if (unit || first[0] == L'한') {
      const std::wstring str[] = {L"",     L"한",   L"두",   L"세",   L"네",
                                  L"다섯", L"여섯", L"일곱", L"여덟", L"아홉"};
      return unit ? str[number] + unit : str[number];
    }
    const wchar_t *str[] = {L"",     first,   L"둘",   L"셋",   L"넷",
                            L"다섯", L"여섯", L"일곱", L"여덟", L"아홉"};
    return str[number];
  }
  if (number < 20) {
    return L"열" + cardinal(number - 10, unit, first);
  }
  if (number == 20) {
    if (unit) {
      return std::wstring(L"스무") + unit;
    }
    return L"스물";
  }
  if (number < 30) {
    return L"스물" + cardinal(number - 20, unit, first);
  }
  if (number < 40) {
    return L"서른" + cardinal(number - 30, unit, first);
  }
  if (number < 50) {
    return L"마흔" + cardinal(number - 40, unit, first);
  }
  if (number < 60) {
    return L"쉰" + cardinal(number - 50, unit, first);
  }
  if (number < 70) {
    return L"예순" + cardinal(number - 60, unit, first);
  }
  if (number < 80) {
    return L"일흔" + cardinal(number - 70, unit, first);
  }
  if (number < 90) {
    return L"여든" + cardinal(number - 80, unit, first);
  }
  if (number < 100) {
    return L"아흔" + cardinal(number - 90, unit, first);
  }
  if (number < 1000) {
    uint64_t quotient = number / 100;
    uint64_t remainder = number % 100;
    return ((quotient == 1) ? L"온" : cardinal(quotient, NULL, L"한") + L"온") +
           cardinal(remainder, unit, first);
  }
  if (number < 10000) {
    uint64_t quotient = number / 1000;
    uint64_t remainder = number % 1000;
    return ((quotient == 1) ? L"즈믄"
                            : cardinal(quotient, NULL, L"한") + L"즈믄") +
           cardinal(remainder, unit, first);
  }
  if (number < 100000000) {
    uint64_t quotient = number / 10000;
    uint64_t remainder = number % 10000;
    return ((quotient == 1) ? L"골" : cardinal(quotient, NULL, L"한") + L"골") +
           cardinal(remainder, unit, first);
  }
  if (number < 1000000000000) {
    uint64_t quotient = number / 100000000;
    uint64_t remainder = number % 100000000;
    return ((quotient == 1) ? L"잘" : cardinal(quotient, NULL, L"한") + L"잘") +
           cardinal(remainder, unit, first);
  }
  if (number < 10000000000000000) {
    uint64_t quotient = number / 1000000000000;
    uint64_t remainder = number % 1000000000000;
    return ((quotient == 1) ? L"울" : cardinal(quotient, NULL, L"한") + L"울") +
           cardinal(remainder, unit, first);
  }
  uint64_t quotient = number / 10000000000000000;
  uint64_t remainder = number % 10000000000000000;
  return ((quotient == 1) ? L"경" : cardinal(quotient, NULL, L"한") + L"경") +
         cardinal(remainder, unit, first);
}
} // namespace numeric

namespace syllable {
inline wchar_t onset(wchar_t c) {
  if (L'ㄱ' <= c && c <= L'ㅎ')
    return c;
  static const wchar_t data[] = {
      L'ㄱ', L'ㄲ', L'ㄴ', L'ㄷ', L'ㄸ', L'ㄹ', L'ㅁ', L'ㅂ', L'ㅃ', L'ㅅ',
      L'ㅆ', L'ㅇ', L'ㅈ', L'ㅉ', L'ㅊ', L'ㅋ', L'ㅌ', L'ㅍ', L'ㅎ'};
  const size_t index = (c - L'가') / (21 * 28);
  if ((sizeof(data) / sizeof(wchar_t)) > index)
    return data[index];
  return L'\0';
}

inline wchar_t nucleus(wchar_t c) {
  static const wchar_t data[] = {L'ㅏ', L'ㅐ', L'ㅑ', L'ㅒ', L'ㅓ', L'ㅔ',
                                 L'ㅕ', L'ㅖ', L'ㅗ', L'ㅘ', L'ㅙ', L'ㅚ',
                                 L'ㅛ', L'ㅜ', L'ㅝ', L'ㅞ', L'ㅟ', L'ㅠ',
                                 L'ㅡ', L'ㅢ', L'ㅣ'};
  if (L'ㅏ' <= c && c <= L'ㅣ')
    return c;
  const size_t index = (c - L'가') % (21 * 28) / 28;
  if ((sizeof(data) / sizeof(wchar_t)) > index)
    return data[index];
  return L'\0';
}

inline wchar_t coda(wchar_t c) {
  static const wchar_t data[] = {
      L'\0', L'ㄱ', L'ㄲ', L'ㄳ', L'ㄴ', L'ㄵ', L'ㄶ', L'ㄷ', L'ㄹ', L'ㄺ',
      L'ㄻ', L'ㄼ', L'ㄽ', L'ㄾ', L'ㄿ', L'ㅀ', L'ㅁ', L'ㅂ', L'ㅄ', L'ㅅ',
      L'ㅆ', L'ㅇ', L'ㅈ', L'ㅊ', L'ㅋ', L'ㅌ', L'ㅍ', L'ㅎ'};
  return data[(c - L'가') % 28];
}

struct letter {
  letter(wchar_t c)
      : value(c), onset(syllable::onset(c)), nucleus(syllable::nucleus(c)),
        coda(syllable::coda(c)) {}
  wchar_t onset;
  wchar_t nucleus;
  wchar_t coda;
  wchar_t value;
  bool valid() const { return onset && nucleus; }
};
} // namespace syllable

/**
 * @brief https://en.wikipedia.org/wiki/Korean_postpositions
 */
namespace postposition {
inline const std::wstring &eul() {
  static const std::wstring eul = L"을";
  return eul;
}
inline const std::wstring &reul() {
  static const std::wstring reul = L"를";
  return reul;
}
inline const std::wstring &eun() {
  static const std::wstring eun = L"은";
  return eun;
}
inline const std::wstring &neun() {
  static const std::wstring neun = L"는";
  return neun;
}
inline const std::wstring &i() {
  static const std::wstring i = L"이";
  return i;
}
inline const std::wstring &ga() {
  static const std::wstring ga = L"가";
  return ga;
}
inline const std::wstring &euro() {
  static const std::wstring euro = L"으로";
  return euro;
}
inline const std::wstring &ro() {
  static const std::wstring ro = L"로";
  return ro;
}
inline const std::wstring &wa() {
  static const std::wstring wa = L"와";
  return wa;
}
inline const std::wstring &gwa() {
  static const std::wstring gwa = L"과";
  return gwa;
}
inline const std::wstring &a() {
  static const std::wstring a = L"아";
  return a;
}
inline const std::wstring &ya() {
  static const std::wstring ya = L"야";
  return ya;
}
inline const std::wstring &iyeo() {
  static const std::wstring iyeo = L"이여";
  return iyeo;
}
inline const std::wstring &yeo() {
  static const std::wstring yeo = L"여";
  return yeo;
}
inline const std::wstring &topic(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? eun() : neun());
}
inline const std::wstring &identifier(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? i() : ga());
}
inline const std::wstring &objective(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? eul() : reul());
}
inline const std::wstring &destination(const std::wstring &nouns) {
  wchar_t w = syllable::coda(ext::back(nouns));
  return (w == '\0' || (w == L'ㄹ') ? ro() : euro());
}
inline const std::wstring &conjunction(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? gwa() : wa());
}
inline const std::wstring &vocative(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? a() : ya());
}
inline const std::wstring &exclamation(const std::wstring &nouns) {
  return (syllable::coda(ext::back(nouns)) ? iyeo() : yeo());
}
} // namespace postposition
} // namespace ko_kr
} // namespace lang
} // namespace ext

#endif // _EXT_LANG_